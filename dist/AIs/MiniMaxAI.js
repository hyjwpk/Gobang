import{AI as t}from"./AI.js";export class MiniMaxAI extends t{constructor(t,i){super(t),this.isBlack=i;const s=t.rows+t.cols+2*(t.rows+t.cols-1);this.myLineScores=Array(s).fill(0),this.opponentLineScores=Array(s).fill(0),this.myTotalScore=0,this.opponentTotalScore=0}getMove(t){if(!t){return{row:Math.floor(this.chessboard.rows/2),col:Math.floor(this.chessboard.cols/2)}}this.updateLineScores(t.row,t.col);const i=this.minimax(5,!0,-1/0,1/0).move;return i&&(this.chessboard.board[i.row][i.col]=this.isBlack,this.updateLineScores(i.row,i.col),this.chessboard.board[i.row][i.col]=null),i}updateLineScores(t,i){const s=[{dr:0,dc:1},{dr:1,dc:0},{dr:1,dc:1},{dr:1,dc:-1}];for(let r=0;r<s.length;r++){const{dr:h,dc:e}=s[r];let o=t,n=i;if(0===h)o=t,n=0;else if(0===e)o=0,n=i;else if(1===h&&1===e){const s=Math.min(t,i);o=t-s,n=i-s}else if(1===h&&-1===e){const s=Math.min(t,this.chessboard.cols-1-i);o=t-s,n=i+s}const c=this.getLineIndex(t,i,h,e),l=this.getLine(o,n,h,e,this.isBlack),d=this.getLine(o,n,h,e,!this.isBlack);this.myTotalScore-=this.myLineScores[c],this.opponentTotalScore-=this.opponentLineScores[c],this.myLineScores[c]=this.evaluateLine(l),this.opponentLineScores[c]=this.evaluateLine(d),this.myTotalScore+=this.myLineScores[c],this.opponentTotalScore+=this.opponentLineScores[c]}}getLineIndex(t,i,s,r){if(0===s)return t;if(0===r)return this.chessboard.rows+i;if(1===s&&1===r)return this.chessboard.rows+this.chessboard.cols+(t-i+(this.chessboard.cols-1));if(1===s&&-1===r)return this.chessboard.rows+this.chessboard.cols+(this.chessboard.rows+this.chessboard.cols-1)+(t+i);throw new Error("Invalid direction")}getLine(t,i,s,r,h){const e=[],o=this.chessboard.rows,n=this.chessboard.cols;for(;t>=0&&t<o&&i>=0&&i<n;){const o=this.chessboard.board[t][i];null===o?e.push("+"):o===h?e.push("1"):e.push("0"),t+=s,i+=r}return e.join("")}evaluateLine(t){let i=0;const s=new Array(t.length).fill(!1);for(const r of Object.keys(MiniMaxAI.ScoreTable)){const h=r.length;let e=0;for(;-1!==(e=t.indexOf(r,e));){let t=!1;for(let i=0;i<h;i++)if("1"===r[i]&&s[e+i]){t=!0;break}if(!t){i+=MiniMaxAI.ScoreTable[r];for(let t=0;t<h;t++)"1"===r[t]&&(s[e+t]=!0)}e++}}return i}minimax(t,i,s,r){if(0===t)return{score:this.evaluateBoard(),move:null};let h=null,e=i?-1/0:1/0;const o=this.getCandidatePositions(i);for(const{row:n,col:c}of o){this.chessboard.board[n][c]=i?this.isBlack:!this.isBlack,this.updateLineScores(n,c);const o=this.checkWin(n,c)?this.minimax(0,!i,s,r):this.minimax(t-1,!i,s,r);if(this.chessboard.board[n][c]=null,this.updateLineScores(n,c),i?(o.score>e&&(e=o.score,h={row:n,col:c}),s=Math.max(s,e)):(o.score<e&&(e=o.score,h={row:n,col:c}),r=Math.min(r,e)),s>=r)return{score:e,move:h}}return null===h?{score:this.evaluateBoard(),move:null}:{score:e,move:h}}getCandidatePositions(t){const i=[],s=[{dr:-1,dc:-1},{dr:-1,dc:0},{dr:-1,dc:1},{dr:0,dc:-1},{dr:0,dc:1},{dr:1,dc:-1},{dr:1,dc:0},{dr:1,dc:1}];for(let r=0;r<this.chessboard.rows;r++)for(let h=0;h<this.chessboard.cols;h++)if(null===this.chessboard.board[r][h]){let e=!1;for(const{dr:t,dc:i}of s){const s=r+t,o=h+i;if(s>=0&&s<this.chessboard.rows&&o>=0&&o<this.chessboard.cols&&null!==this.chessboard.board[s][o]){e=!0;break}}if(e){this.chessboard.board[r][h]=t?this.isBlack:!this.isBlack,this.updateLineScores(r,h);const s=this.evaluateBoard();this.chessboard.board[r][h]=null,this.updateLineScores(r,h),i.push({row:r,col:h,score:s})}}i.sort(((i,s)=>t?s.score-i.score:i.score-s.score));return i.slice(0,10).map((({row:t,col:i})=>({row:t,col:i})))}evaluateBoard(){return this.myTotalScore-this.opponentTotalScore}checkWin(t,i){return this.checkDirection(t,i,0,1)||this.checkDirection(t,i,1,0)||this.checkDirection(t,i,1,1)||this.checkDirection(t,i,1,-1)}checkDirection(t,i,s,r){const h=!0===this.chessboard.board[t][i];let e=1;return e+=this.countInDirection(t,i,s,r,h),e+=this.countInDirection(t,i,-s,-r,h),e>=5}countInDirection(t,i,s,r,h){let e=0,o=t+s,n=i+r;for(;o>=0&&o<this.chessboard.rows&&n>=0&&n<this.chessboard.cols&&this.chessboard.board[o][n]===h;)e++,o+=s,n+=r;return e}undoLastMove(t){this.updateLineScores(t.row,t.col)}}MiniMaxAI.ScoreTable={11111:5e4,"+1111+":4320,"+111++":720,"++111+":720,"+11+1+":720,"+1+11+":720,"1111+":720,"+1111":720,"11+11":720,"1+111":720,"111+1":720,"++11++":120,"++1+1+":120,"+1+1++":120,"+++1++":20,"++1+++":20};